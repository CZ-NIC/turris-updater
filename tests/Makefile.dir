
.PHONY: check-clean test valgrind luacheck check test-locks valgrind-locks luac-autoload luacheck coverage $(O)/.coverage.info

BINARIES_NOTARGET += tests/locks
locks_MODULES += locks
locks_LOCAL_LIBS += updater

$(O)/tests/luacheck-compiled/bin/luacheck:
	mkdir -p $(O)/tests/luacheck-compiled
	cd $(S)/tests/luacheck && ./install.lua $(abspath $(O)/tests/luacheck-compiled)

clean: check-clean
check-clean:
	rm -rf $(O)/tests/luacheck-compiled

C_TESTS := \
	arguments \
	events \
	interpreter

LUA_TESTS := \
	backend \
	events \
	interpreter \
	journal \
	planner \
	postprocess \
	requests \
	sandbox \
	transaction \
	utils \
	uri \
	picosat

ifdef COV
LUA_TESTS += coverage

# Aggregates coverage to info file for genhtml.
# It uses lcov for coverage from C sources and our script for coverage from Lua
# No dependencies are intentional, this way coverage can be run for all tests or
# just for small subset of them. It's on user to prepare data by launching tests.
$(O)/.coverage.info:
	lcov --capture --directory $(O) --base-directory $(S) --output-file $@
	$(S)/tests/lua_coverage2info.pl $(O)/.lua_coverage $@ $(S)

coverage: $(O)/.coverage.info
	genhtml $< --output-directory $(O)/coverage
endif
clean: clean-coverage clean-openssl
clean-coverage:
	rm -rf $(O)/.lua_coverage
	rm -f  $(O)/.coverage.info
	rm -rf $(O)/coverage

# Ignore stacktraceplus and dumper, not our creation.
LUA_AUTOLOAD := $(filter-out 01_stacktraceplus 05_dumper,$(patsubst a_%.lua,%,$(notdir $(wildcard $(S)/src/lib/autoload/a_*.lua))))

TEST_URIINTERNAL := $(abspath $(wildcard $(S)/tests/internal/*))
$(O)/.gen/tests/uriinternal.embedlist: $(S)/src/lib/gen_embed.sh $(S)/src/lib/embed_types.h $(TEST_URIINTERNAL)
	$(M) GEN $@
	$(Q) mkdir -p $(dir $@)
	$(Q)$< "" uriinternal $(S)/src/lib/embed_types.h $(TEST_URIINTERNAL) >$@

define DO_C_TEST

BINARIES_NOTARGET += tests/ctest-$(1)
ctest-$(1)_MODULES += $(1) uriinternal.embed ctest
ctest-$(1)_SYSTEM_LIBS += m rt
ctest-$(1)_PKG_CONFIGS += check
ctest-$(1)_LOCAL_LIBS += updater

test: test-c-$(1)
valgrind: valgrind-c-$(1)

endef

$(eval $(foreach TEST,$(C_TESTS),$(call DO_C_TEST,$(TEST))))
test: $(addprefix test-lua-,$(LUA_TESTS))
valgrind: $(addprefix valgrind-lua-,$(LUA_TESTS))
luac-autoload: $(addprefix luac-autoload-,$(LUA_AUTOLOAD))
luacheck: $(addprefix luacheck-,$(LUA_AUTOLOAD))

# Use the FORCE target instead of .PHONY, since .PHONY doesn't work well
# with patterned recipes. The FORCE comes from our shared build system.

TESTS_ENV = SUPPRESS_LOG=1 S=$(S) TMPDIR=$(abspath $(O)/testdir) COVERAGEDIR=$(abspath $(O)/.lua_coverage)


# Common distributions are compiling openssl without -DPURITY flag. This causes
# problems with valgrind so we compile our own version to be used for valgrind
# tests.
# See: https://www.openssl.org/docs/faq.html
OPENSSL_TEST_VERSION := $(shell openssl version | awk '{print $$2}')
OPENSSL_BUILD_PATH = $(O)/tests/openssl
OPENSSL_LIBS = $(OPENSSL_BUILD_PATH)/openssl-$(OPENSSL_TEST_VERSION)/libcrypto.so $(OPENSSL_BUILD_PATH)/openssl-$(OPENSSL_TEST_VERSION)/libssl.so
OPENSSL_ENV = LD_LIBRARY_PATH=$(OPENSSL_BUILD_PATH)/openssl-$(OPENSSL_TEST_VERSION):$$LD_LIBRARY_PATH

$(OPENSSL_BUILD_PATH)/openssl-$(OPENSSL_TEST_VERSION).tar.gz:
	mkdir -p $(OPENSSL_BUILD_PATH)
	wget https://www.openssl.org/source/openssl-$(OPENSSL_TEST_VERSION).tar.gz -O $@

# Usage of pattern with multiple targets causes gmake to understand that all of
# those files are produced by this target at once. So this target is run only
# once. See: https://www.gnu.org/software/make/manual/make.html#Pattern-Examples
OPENSSL_LIBS_TARGET = $(OPENSSL_BUILD_PATH)/%/libcrypto.so $(OPENSSL_BUILD_PATH)/%/libssl.so
$(OPENSSL_LIBS_TARGET): $(OPENSSL_BUILD_PATH)/openssl-$(OPENSSL_TEST_VERSION).tar.gz
	tar -xzf $< -C $(OPENSSL_BUILD_PATH)
	cd $(OPENSSL_BUILD_PATH)/openssl-$(OPENSSL_TEST_VERSION) && ./config shared -DPURIFY
	+$(MAKE) -C $(OPENSSL_BUILD_PATH)/openssl-$(OPENSSL_TEST_VERSION)
# Make marks these libraries as intermediate, but we need we don't want them
# compile every time so lets set them as precious.
.PRECIOUS: $(OPENSSL_LIBS_TARGET)

clean-openssl:
	rm -rf $(OPENSSL_BUILD_PATH)

# Tests
test-c-%: $(O)/bin/ctest-% FORCE
	mkdir -p $(O)/testdir
	$(TESTS_ENV) $<

valgrind-c-%: $(O)/bin/ctest-% $(OPENSSL_LIBS) FORCE
	mkdir -p $(O)/testdir
	CK_FORK=no $(TESTS_ENV) $(OPENSSL_ENV) $(VALGRIND) $<

test-lua-%: $(S)/tests/%.lua $(O)/bin/lulaunch FORCE
	mkdir -p $(O)/testdir
	$(TESTS_ENV) $(O)/bin/lulaunch $<

valgrind-lua-%: $(S)/tests/%.lua $(O)/bin/lulaunch $(OPENSSL_LIBS) FORCE
	mkdir -p $(O)/testdir
	$(TESTS_ENV) $(OPENSSL_ENV) $(VALGRIND) $(O)/bin/lulaunch $<

luac-autoload-%: $(S)/src/lib/autoload/a_%.lua FORCE
	luac -p $<

luacheck-%: $(S)/src/lib/autoload/a_%.lua $(O)/tests/luacheck-compiled/bin/luacheck $(S)/tests/luacheck.config FORCE
	$(O)/tests/luacheck-compiled/bin/luacheck --config $(S)/tests/luacheck.config $<

test-locks: $(O)/bin/locks
	$(O)/bin/locks

valgrind-locks: $(O)/bin/locks
	$(VALGRIND) $(O)/bin/locks

# In uri test we are connecting to api.turris.cz and this downloads us crl
test-lua-uri: $(S)/tests/api.turris.cz.crl.pem
# Always download to ensure that it won't timeout
$(S)/tests/api.turris.cz.crl.pem: FORCE
	curl -k https://api.turris.cz/crl -o $@

test: test-locks
valgrind: valgrind-locks
check: test valgrind luac-autoload luacheck cppcheck

include $(S)/tests/lunit-launch/Makefile.dir
include $(S)/tests/system/Makefile.dir
