The battle plan
===============

This is a temporary document, listing the first idea about what task
are needed to implement the updater and what is the order to do so.
Before the implementation begins, this may be turned into set of tasks
in a bugtracer. It may turn outdated after a while, but we may want to
preserve it nevertheless during the implementation phase, to keep some
kind of overview of the work.

Rationale
---------

The updater may be a big piece of software. It may be better to start
testing and putting parts of it into production before the whole is
complete.

Considering that we want to replace opkg in the end completely, but
keep the on-disk structures backwards compatible (eg. just adding some
more files), it makes sense to start doing the replacement, or parts
of it, first.

The current shell version of updater uses opkg to install the
packages, but uses various hacks to bend it to its will, therefore
using the backend parts of the new updater from there makes certain
sense.  Therefore, we probably want to create the part that installs
and uninstalls packages, with support for transactions.

Development milestones
----------------------

The milestones mark levels of functionality that need to be reached
for the new updater get some usability.

Installation backend
~~~~~~~~~~~~~~~~~~~~

Once the updater has the ability to install and remove packages in a
transaction and update the on-disk database, it would be integrated
into the old updater to gain some testing. The command line interface
used here would get removed in future releases.

Libc replacement support
~~~~~~~~~~~~~~~~~~~~~~~~

We will need to replace libc (uclibc is being deprecated and moving to
muscl is strongly recommended). But doing so may be little complex. It
surely needs to reinstall everything in the system. But we need to do
it in a way in which we don't cut the branch we're sitting on. Some
tricks with static linking and bundling of statically-linked busybox
inside the updater may help. Also, there exist some trick called fat
elf.

Note that this is independent of the following two milestones, it may
be done in the backend-only binary. It depends on when we want to
switch the libc.

Replacement for old updater
~~~~~~~~~~~~~~~~~~~~~~~~~~~

At this stage, it can download the configuration scripts, run them,
parse repositories, resolve dependencies and install the packages.

However, all the fancy features are not expected yet. The dependency
resolution is done through trivial DFS, priorities of intentions or
repositories are not implemented, same as many extended options of
commands or merging of package descriptions. Complex dependency
descriptions might be missing as well.

This however contains compatibility wrappers to provide opkg and
updater.sh interface, so it can be used as a drop-in replacement of
both opkg and old updater.

Full support of the requirements and language
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

All the rest of the fancyness comes here. This includes resolution of
conflicting dependencies, OR-dependencies, negative dependencies,
merging of package descriptions, etc. This will likely contain
implementing some trivial constraint solver with backtracking
abilities and thorough testing.

Identified tasks
----------------

These are just for the first milestone. More splitting into tasks shall
be done later.

* Parse command line. This is the trivial command line, listing
  already downloaded packages to be installed or removed, or some
  special command (like recover journal).
* Integrate the lua interpreter (just the trivial part, ability to run
  a lua script from a file or string).
* Parse the current package state.
* The event loop:
  - Integrate libevent
  - Handle terminated children (libevent has only generic „Signal
    happened).
  - Some kind of „wait“ mode of running the loop ‒ list needed events,
    provide a function to wait for them. Consider running this from
    within a callback of the running loop.
* Process manager:
  - Interface.
  - Starting the process.
  - Redirection of IO, specifying callbacks.
  - Possibility to load output to or input from a buffer.
* Unpacking of packages into a temporary location.
* Finding leftover files not needed after upgrades or package
  removals.
* Merging of the temporary location into the live system.
* Running post/pre-install/remove scripts of packages.
* Saving of package state.
* Locking to prevent parallel run (look at what opkg uses).
* Journal reading and writing.
* Using journal through the installation.
* Integrating the new backend into old updater and releasing.
